diff -Naur libpcap-1.0.0/if_packet.h libpcap-1.0.0-nanosecond/if_packet.h
--- libpcap-1.0.0/if_packet.h	1970-01-01 01:00:00.000000000 +0100
+++ libpcap-1.0.0-nanosecond/if_packet.h	2011-09-09 10:16:51.071397251 +0200
@@ -0,0 +1,150 @@
+#ifndef __LINUX_IF_PACKET_H
+#define __LINUX_IF_PACKET_H
+
+#include <linux/types.h>
+
+struct sockaddr_pkt
+{
+	unsigned short spkt_family;
+	unsigned char spkt_device[14];
+	__be16 spkt_protocol;
+};
+
+struct sockaddr_ll
+{
+	unsigned short	sll_family;
+	__be16		sll_protocol;
+	int		sll_ifindex;
+	unsigned short	sll_hatype;
+	unsigned char	sll_pkttype;
+	unsigned char	sll_halen;
+	unsigned char	sll_addr[8];
+};
+
+/* Packet types */
+
+#define PACKET_HOST		0		/* To us		*/
+#define PACKET_BROADCAST	1		/* To all		*/
+#define PACKET_MULTICAST	2		/* To group		*/
+#define PACKET_OTHERHOST	3		/* To someone else 	*/
+#define PACKET_OUTGOING		4		/* Outgoing of any type */
+/* These ones are invisible by user level */
+#define PACKET_LOOPBACK		5		/* MC/BRD frame looped back */
+#define PACKET_FASTROUTE	6		/* Fastrouted frame	*/
+
+/* Packet socket options */
+
+#define PACKET_ADD_MEMBERSHIP		1
+#define PACKET_DROP_MEMBERSHIP		2
+#define PACKET_RECV_OUTPUT		3
+/* Value 4 is still used by obsolete turbo-packet. */
+#define PACKET_RX_RING			5
+#define PACKET_STATISTICS		6
+#define PACKET_COPY_THRESH		7
+#define PACKET_AUXDATA			8
+#define PACKET_ORIGDEV			9
+#define PACKET_VERSION			10
+#define PACKET_HDRLEN			11
+#define PACKET_RESERVE			12
+#define PACKET_TX_RING			13
+#define PACKET_LOSS			14
+
+struct tpacket_stats
+{
+	unsigned int	tp_packets;
+	unsigned int	tp_drops;
+};
+
+struct tpacket_auxdata
+{
+	__u32		tp_status;
+	__u32		tp_len;
+	__u32		tp_snaplen;
+	__u16		tp_mac;
+	__u16		tp_net;
+	__u16		tp_vlan_tci;
+};
+
+/* Rx ring - header status */
+#define TP_STATUS_KERNEL	0x0
+#define TP_STATUS_USER		0x1
+#define TP_STATUS_COPY		0x2
+#define TP_STATUS_LOSING	0x4
+#define TP_STATUS_CSUMNOTREADY	0x8
+
+/* Tx ring - header status */
+#define TP_STATUS_AVAILABLE	0x0
+#define TP_STATUS_SEND_REQUEST	0x1
+#define TP_STATUS_SENDING	0x2
+#define TP_STATUS_WRONG_FORMAT	0x4
+
+struct tpacket_hdr
+{
+	unsigned long	tp_status;
+	unsigned int	tp_len;
+	unsigned int	tp_snaplen;
+	unsigned short	tp_mac;
+	unsigned short	tp_net;
+	unsigned int	tp_sec;
+	unsigned int	tp_nsec;
+};
+
+#define TPACKET_ALIGNMENT	16
+#define TPACKET_ALIGN(x)	(((x)+TPACKET_ALIGNMENT-1)&~(TPACKET_ALIGNMENT-1))
+#define TPACKET_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket_hdr)) + sizeof(struct sockaddr_ll))
+
+struct tpacket2_hdr
+{
+	__u32		tp_status;
+	__u32		tp_len;
+	__u32		tp_snaplen;
+	__u16		tp_mac;
+	__u16		tp_net;
+	__u32		tp_sec;
+	__u32		tp_nsec;
+	__u16		tp_vlan_tci;
+};
+
+#define TPACKET2_HDRLEN		(TPACKET_ALIGN(sizeof(struct tpacket2_hdr)) + sizeof(struct sockaddr_ll))
+
+enum tpacket_versions
+{
+	TPACKET_V1,
+	TPACKET_V2,
+};
+
+/*
+   Frame structure:
+
+   - Start. Frame must be aligned to TPACKET_ALIGNMENT=16
+   - struct tpacket_hdr
+   - pad to TPACKET_ALIGNMENT=16
+   - struct sockaddr_ll
+   - Gap, chosen so that packet data (Start+tp_net) alignes to TPACKET_ALIGNMENT=16
+   - Start+tp_mac: [ Optional MAC header ]
+   - Start+tp_net: Packet data, aligned to TPACKET_ALIGNMENT=16.
+   - Pad to align to TPACKET_ALIGNMENT=16
+ */
+
+struct tpacket_req
+{
+	unsigned int	tp_block_size;	/* Minimal size of contiguous block */
+	unsigned int	tp_block_nr;	/* Number of blocks */
+	unsigned int	tp_frame_size;	/* Size of frame */
+	unsigned int	tp_frame_nr;	/* Total number of frames */
+};
+
+struct packet_mreq
+{
+	int		mr_ifindex;
+	unsigned short	mr_type;
+	unsigned short	mr_alen;
+	unsigned char	mr_address[8];
+};
+
+#define PACKET_MR_MULTICAST	0
+#define PACKET_MR_PROMISC	1
+#define PACKET_MR_ALLMULTI	2
+#define PACKET_MR_UNICAST	3
+
+#endif
diff -Naur libpcap-1.0.0/pcap/pcap.h libpcap-1.0.0-nanosecond/pcap/pcap.h
--- libpcap-1.0.0/pcap/pcap.h	2011-09-09 10:16:52.161709004 +0200
+++ libpcap-1.0.0-nanosecond/pcap/pcap.h	2011-09-09 10:16:50.941110214 +0200
@@ -152,7 +152,7 @@
  * that's not what the underlying packet capture mechanism supplies.
  */
 struct pcap_pkthdr {
-	struct timeval ts;	/* time stamp */
+	struct timespec ts;	/* time stamp */
 	bpf_u_int32 caplen;	/* length of portion present */
 	bpf_u_int32 len;	/* length this packet (off wire) */
 };
diff -Naur libpcap-1.0.0/pcap-int.h libpcap-1.0.0-nanosecond/pcap-int.h
--- libpcap-1.0.0/pcap-int.h	2011-09-09 10:16:52.321407603 +0200
+++ libpcap-1.0.0-nanosecond/pcap-int.h	2011-09-09 10:16:51.211396766 +0200
@@ -318,9 +318,9 @@
  * the file was written.
  */
 
-struct pcap_timeval {
+struct pcap_timespec {
     bpf_int32 tv_sec;		/* seconds */
-    bpf_int32 tv_usec;		/* microseconds */
+    bpf_int32 tv_nsec;		/* nanoseconds */
 };
 
 /*
@@ -353,7 +353,7 @@
  */
 
 struct pcap_sf_pkthdr {
-    struct pcap_timeval ts;	/* time stamp */
+    struct pcap_timespec ts;	/* time stamp */
     bpf_u_int32 caplen;		/* length of portion present */
     bpf_u_int32 len;		/* length this packet (off wire) */
 };
@@ -369,7 +369,7 @@
  */
 
 struct pcap_sf_patched_pkthdr {
-    struct pcap_timeval ts;	/* time stamp */
+    struct pcap_timespec ts;	/* time stamp */
     bpf_u_int32 caplen;		/* length of portion present */
     bpf_u_int32 len;		/* length this packet (off wire) */
     int		index;
diff -Naur libpcap-1.0.0/pcap-linux.c libpcap-1.0.0-nanosecond/pcap-linux.c
--- libpcap-1.0.0/pcap-linux.c	2011-09-09 10:16:52.111396683 +0200
+++ libpcap-1.0.0-nanosecond/pcap-linux.c	2011-09-09 11:03:25.481083571 +0200
@@ -152,7 +152,8 @@
  * it shouldn't cause any problems.
  */
 #ifdef PF_PACKET
-# include <linux/if_packet.h>
+#include "if_packet.h"
+//# include <linux/if_packet.h>
 
  /*
   * On at least some Linux distributions (for example, Red Hat 5.2),
@@ -516,7 +517,7 @@
 	handle->cleanup_op = pcap_cleanup_linux;
 	handle->read_op = pcap_read_linux;
 	handle->stats_op = pcap_stats_linux;
-
+	
 	/*
 	 * NULL and "any" are special devices which give us the hint to
 	 * monitor all devices.
@@ -890,11 +891,13 @@
 
 	/* Fill in our own header data */
 
-	if (ioctl(handle->fd, SIOCGSTAMP, &pcap_header.ts) == -1) {
-		snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
-			 "SIOCGSTAMP: %s", pcap_strerror(errno));
-		return -1;
-	}
+	//if (ioctl(handle->fd, SIOCGSTAMP, &pcap_header.ts) == -1) {
+	//	snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,
+	//		 "SIOCGSTAMPNS: %s", pcap_strerror(errno));
+	//	return -1;
+	//}
+        
+
 	pcap_header.caplen	= caplen;
 	pcap_header.len		= packet_len;
 
@@ -2163,7 +2166,6 @@
 		u_char *user)
 {
 	int pkts = 0;
-
 	/* wait for frames availability.*/
 	if ((handle->md.timeout >= 0) &&
 	    !pcap_get_ring_frame(handle, TP_STATUS_USER)) {
@@ -2203,7 +2205,7 @@
 		unsigned int tp_mac;
 		unsigned int tp_snaplen;
 		unsigned int tp_sec;
-		unsigned int tp_usec;
+		unsigned int tp_nsec;
 
 		h.raw = pcap_get_ring_frame(handle, TP_STATUS_USER);
 		if (!h.raw)
@@ -2215,7 +2217,7 @@
 			tp_mac	   = h.h1->tp_mac;
 			tp_snaplen = h.h1->tp_snaplen;
 			tp_sec	   = h.h1->tp_sec;
-			tp_usec	   = h.h1->tp_usec;
+			tp_nsec	   = h.h1->tp_nsec;
 			break;
 #ifdef HAVE_TPACKET2
 		case TPACKET_V2:
@@ -2223,7 +2225,7 @@
 			tp_mac	   = h.h2->tp_mac;
 			tp_snaplen = h.h2->tp_snaplen;
 			tp_sec	   = h.h2->tp_sec;
-			tp_usec	   = h.h2->tp_nsec / 1000;
+			tp_nsec	   = h.h2->tp_nsec;
 			break;
 #endif
 		default:
@@ -2266,7 +2268,7 @@
 
 		/* get required packet info from ring header */
 		pcaphdr.ts.tv_sec = tp_sec;
-		pcaphdr.ts.tv_usec = tp_usec;
+		pcaphdr.ts.tv_nsec = tp_nsec;
 		pcaphdr.caplen = tp_snaplen;
 		pcaphdr.len = tp_len;
 
diff -Naur libpcap-1.0.0/pcap-usb-linux.c libpcap-1.0.0-nanosecond/pcap-usb-linux.c
--- libpcap-1.0.0/pcap-usb-linux.c	2011-09-09 10:16:52.261709152 +0200
+++ libpcap-1.0.0-nanosecond/pcap-usb-linux.c	2011-09-09 10:16:51.111396454 +0200
@@ -366,7 +366,7 @@
 		return -1;
 	}
 	uhdr->ts_sec = pkth.ts.tv_sec;
-	uhdr->ts_usec = pkth.ts.tv_usec;
+	uhdr->ts_usec = pkth.ts.tv_nsec;
 
 	/* parse endpoint information */
 	if (pipeid1 == 'C')
@@ -638,7 +638,7 @@
 	pkth.caplen = clen + sizeof(pcap_usb_header);
 	pkth.len = info.hdr->urb_len + sizeof(pcap_usb_header);
 	pkth.ts.tv_sec = info.hdr->ts_sec;
-	pkth.ts.tv_usec = info.hdr->ts_usec;
+	pkth.ts.tv_nsec = info.hdr->ts_usec;
 
 	handle->md.packets_read++;
 	callback(user, &pkth, handle->buffer);
@@ -703,7 +703,7 @@
 			pkth.caplen = hdr->data_len + sizeof(pcap_usb_header);
 			pkth.len = hdr->urb_len + sizeof(pcap_usb_header);
 			pkth.ts.tv_sec = hdr->ts_sec;
-			pkth.ts.tv_usec = hdr->ts_usec;
+			pkth.ts.tv_nsec = hdr->ts_usec;
 
 			handle->md.packets_read++;
 			callback(user, &pkth, (u_char*) hdr);
diff -Naur libpcap-1.0.0/savefile.c libpcap-1.0.0-nanosecond/savefile.c
--- libpcap-1.0.0/savefile.c	2011-09-09 10:16:52.301088218 +0200
+++ libpcap-1.0.0-nanosecond/savefile.c	2011-09-09 10:16:51.181249868 +0200
@@ -1008,7 +1008,7 @@
 {
 	struct pcap_file_header hdr;
 
-	hdr.magic = TCPDUMP_MAGIC;
+	hdr.magic = NSEC_TCPDUMP_MAGIC;
 	hdr.version_major = PCAP_VERSION_MAJOR;
 	hdr.version_minor = PCAP_VERSION_MINOR;
 
@@ -1423,12 +1423,12 @@
 		hdr->caplen = SWAPLONG(sf_hdr.caplen);
 		hdr->len = SWAPLONG(sf_hdr.len);
 		hdr->ts.tv_sec = SWAPLONG(sf_hdr.ts.tv_sec);
-		hdr->ts.tv_usec = SWAPLONG(sf_hdr.ts.tv_usec);
+		hdr->ts.tv_nsec = SWAPLONG(sf_hdr.ts.tv_nsec);
 	} else {
 		hdr->caplen = sf_hdr.caplen;
 		hdr->len = sf_hdr.len;
 		hdr->ts.tv_sec = sf_hdr.ts.tv_sec;
-		hdr->ts.tv_usec = sf_hdr.ts.tv_usec;
+		hdr->ts.tv_nsec = sf_hdr.ts.tv_nsec;
 	}
 	/* Swap the caplen and len fields, if necessary. */
 	switch (p->sf.lengths_swapped) {
@@ -1621,7 +1621,7 @@
 
 	f = (FILE *)user;
 	sf_hdr.ts.tv_sec  = h->ts.tv_sec;
-	sf_hdr.ts.tv_usec = h->ts.tv_usec;
+	sf_hdr.ts.tv_nsec = h->ts.tv_nsec;
 	sf_hdr.caplen     = h->caplen;
 	sf_hdr.len        = h->len;
 	/* XXX we should check the return status */
